package cms

import (
	"context"
	"strings"

	"go.ytsaurus.tech/library/go/ptr"
	"go.ytsaurus.tech/yt/admin/cms/internal/models"
	"go.ytsaurus.tech/yt/go/guid"
	"go.ytsaurus.tech/yt/go/ypath"
	"go.ytsaurus.tech/yt/go/yt"
	"go.ytsaurus.tech/yt/go/ytsys"
)

const (
	robotCMS   = "robot-yt-cms"
	robotShiva = "robot-yt-shiva"

	directMaintenanceComment = "Generated by directly setting corresponding flag"
)

// nopLocker is an implementations of sync.Locker that does nothing.
type nopLocker int

func (l nopLocker) Lock() {}

func (l nopLocker) Unlock() {}

func containCMSMaintenanceRequest(reqs ytsys.SystemMaintenanceRequestMap, t yt.MaintenanceType) bool {
	for _, req := range reqs {
		if req.User == robotCMS && req.Type == t {
			return true
		}
	}
	return false
}

func removeMaintenances(
	ctx context.Context,
	dc DiscoveryClient,
	addr *ytsys.Addr,
	component yt.MaintenanceComponent,
	typ yt.MaintenanceType,
) error {
	node := ctx.Value(nodeKey).(*ytsys.Node)

	guids := make([]yt.MaintenanceID, 0)
	for id, req := range node.MaintenanceRequests {
		if req.Type == typ && strings.HasPrefix(req.Comment, directMaintenanceComment) && req.User != robotShiva {
			guid, _ := guid.ParseString(id)
			guids = append(guids, yt.MaintenanceID(guid))
		}
	}

	// remove other maintenances generated by directly setting flag
	if len(guids) != 0 {
		if _, err := dc.RemoveMaintenance(ctx, component, addr, &yt.RemoveMaintenanceOptions{IDs: guids}); err != nil {
			return err
		}
	}

	// remove cms maintenances
	_, err := dc.RemoveMaintenance(ctx, yt.MaintenanceComponentClusterNode, addr, &yt.RemoveMaintenanceOptions{
		Mine: ptr.Bool(true),
		Type: ptr.T(typ),
	})

	return err
}

func enableSchedulerJobs(ctx context.Context, dc DiscoveryClient, r *models.Node, useMaintenanceAPI bool) error {
	if useMaintenanceAPI {
		return removeMaintenances(ctx, dc, r.Addr, yt.MaintenanceComponentClusterNode, yt.MaintenanceTypeDisableSchedulerJobs)
	}
	return dc.EnableSchedulerJobs(ctx, r.Addr)
}

func disableSchedulerJobs(ctx context.Context, dc DiscoveryClient, r *models.Node, useMaintenanceAPI bool) error {
	if useMaintenanceAPI {
		_, err := dc.AddMaintenance(
			ctx,
			yt.MaintenanceComponentClusterNode,
			r.Addr,
			yt.MaintenanceTypeDisableSchedulerJobs,
			"",
			nil,
		)
		return err
	}
	return dc.DisableSchedulerJobs(ctx, r.Addr)
}

func enableWriteSessions(ctx context.Context, dc DiscoveryClient, r *models.Node, useMaintenanceAPI bool) error {
	if useMaintenanceAPI {
		return removeMaintenances(ctx, dc, r.Addr, yt.MaintenanceComponentClusterNode, yt.MaintenanceTypeDisableWriteSessions)
	}
	return dc.EnableWriteSessions(ctx, r.Addr)
}

func disableWriteSessions(ctx context.Context, dc DiscoveryClient, r *models.Node, useMaintenanceAPI bool) error {
	if useMaintenanceAPI {
		_, err := dc.AddMaintenance(
			ctx,
			yt.MaintenanceComponentClusterNode,
			r.Addr,
			yt.MaintenanceTypeDisableWriteSessions,
			"",
			nil,
		)
		return err
	}
	return dc.DisableWriteSessions(ctx, r.Addr)
}

func unbanNode(ctx context.Context, dc DiscoveryClient, node *ytsys.Node, useMaintenanceAPI bool) error {
	if useMaintenanceAPI {
		_, err := dc.RemoveMaintenance(ctx, yt.MaintenanceComponentClusterNode, node.Addr, &yt.RemoveMaintenanceOptions{
			Type: ptr.T(yt.MaintenanceTypeBan),
		})
		return err
	}
	return dc.Unban(ctx, node)
}

func banNode(ctx context.Context, dc DiscoveryClient, node *ytsys.Node, useMaintenanceAPI bool, banMsg string) error {
	if useMaintenanceAPI {
		_, err := dc.AddMaintenance(
			ctx,
			yt.MaintenanceComponentClusterNode,
			node.Addr,
			yt.MaintenanceTypeBan,
			"",
			nil,
		)
		return err
	}

	return dc.Ban(ctx, node, banMsg)
}

func unmarkNodeDecommissioned(ctx context.Context, dc DiscoveryClient, useMaintenanceAPI bool) error {
	node := ctx.Value(nodeKey).(*ytsys.Node)

	if useMaintenanceAPI {
		return removeMaintenances(ctx, dc, node.Addr, yt.MaintenanceComponentClusterNode, yt.MaintenanceTypeDisableWriteSessions)
	}
	return dc.UnmarkNodeDecommissioned(ctx, node.Addr)
}

func markNodeDecommissioned(
	ctx context.Context, dc DiscoveryClient, node *ytsys.Node,
	useMaintenanceAPI bool,
	decommisionMsg string,
) error {
	if useMaintenanceAPI {
		_, err := dc.AddMaintenance(
			ctx,
			yt.MaintenanceComponentClusterNode,
			node.Addr,
			yt.MaintenanceTypeDecommission,
			"",
			nil,
		)
		return err
	}
	return dc.MarkNodeDecommissioned(ctx, node.Addr, decommisionMsg)
}

func getPodIDFromYPath(path ypath.Path) string {
	pathSplit := strings.Split(path.String(), "/")
	addr := pathSplit[len(pathSplit)-1]
	shortAddr := strings.Split(addr, ".")[0]

	return shortAddr
}
